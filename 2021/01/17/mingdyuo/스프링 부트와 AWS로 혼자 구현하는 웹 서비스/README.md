## 스프링 부트와 AWS로 혼자 구현하는 웹 서비스



4. 머스테치로 화면 구성하기

   4.1 서버 템플릿 엔진과 머스테치 소개

   - 템플릿 엔진이란

     - 지정된 템플릿 양식과 데이터가 합쳐져 HTML 문서를 출력하는 소프트웨어

     1. 서버 템플릿 엔진 : JSP, Freemarker 등
        - 서버 템플릿 엔진은 서버에서 구동됨
        - 화면 생성을 할 때, 서버에서 Java 코드로 문자열을 만든 뒤 이 문자열을 HTML로 변환하여 브라우저로 전달함
     2. 클라이언트 템플릿 엔진 : 리액트, 뷰 등 
        - 자바 스크립트는 브라우저 위에서 작동됨, 즉 코드의 실행 장소는 서버가 아닌 브라우저, 따라서 서버의 제어를 받을 수 없음
        - 이런 SPA(Single Page Application)는 브라우저에서 화면을 생성함. 
        - 서버에서는 Json, Xml 형식의 데이터만 전달하고 클라이언트에서 조립함
        - 최근데는 리액트나 뷰에서 서버사이드 렌더링을 지원하기도 하는데, 아무튼 그렇다.
        - 스프링 부트를 사용하면서 JS를 서버사이드에서 렌더링하도록 구현하는 것은 많은 수고가 필요함. 

   - [머스테치](http://mustache.github.io)란

     - 수많은 언어를 지원하는 가장 심플한 템플릿 엔진

     - 현존 대부분 언어를 지원 

       → 자바에서 사용 시 서버 템플릿 엔진, JS 사용시 클라이언트 템플릿 엔진으로 사용 가능

     - 장점은 문법이 심플하고, 로직 코드를 사용할 수 없으므로 view 역할과 서버 역할이 명확히 분리되며, *.js와 *.java 둘 다 있으므로 문법 하나로 클라/서버 템플릿 모두 사용 가능하다는 것임.

     - 그 외에 JSP, Velocity, Freemarker, Thymeleaf 등이 있음

       

   4.2 기본 페이지 만들기

   - 머스테치 파일의 기본 위치

     `src/main/resources/templates`

   - 머스테치 스타터는 컨트롤러에서 문자열 반환 시 앞의 경로와 뒤의 파일 확장자를 자동으로 지정함

     앞의 경로는 `src/main/resources/templates`이고 뒤의 파일 확장자는 `.mustache`가 붙는데, 컨트롤러에서 `"index"`를 반환하므로 `src/main/resources/templates.mustache`로 전환 되며 View Resolver가 처리한다.

     (View Resolver란 URL 요청의 결과를 전달할 타입과 값을 지정하는 관리자 격으로 볼 수 ㅣ있다.)

     

   4.3 게시글 등록 화면 만들기

   - 프론트 엔드 라이브러리 사용하는 방법

     1. 외부 CDN을 사용

        간단하므로 이번 프로젝트에서 사용할 것이지만, 외부에 의존하는 것이기 때문에 실제 서비스에서는 잘 사용하지 않는다. 

     2. 직접 라이브러리를 받아서 사용

        npm/bower/yarn + grunt/gulp/webpack 등

   - 레이아웃 방식의 외부 CDN 추가

     공통 영역을 별도의 파일로 분리하여 필요한 곳에서 가져다 쓰는 방식

   - 부트스트랩은 제이쿼리에 의존

   - js 파일들에 같은 이름의 함수가 있다면, 브라우저 내 공용 공간 스코프에 모두 들어가기 때문에 나중에 로딩된 함수가 이전에 로딩된 함수를 덮어쓰게 된다. 이를 해결하기 위해 파일 내에서 유효 범위를 만들어 사용한다.

     (ex) 페이지 별 init(), save() 등

     var 객체를 만들어 해당 객체 내에 필요한 모든 function을 선언하는 방식으로 사용

   - index.js의 호출 경로는 절대경로로 바로 시작한다. 기본적으로 `src/main/resources/static`에 위치한 js, css, image 등의 정적 파일은 url에서 `/`로 설정된다.

   - `index.mustache`

     1. `{{#posts}}`

        - posts라는 List를 순회한다.

        - java의 for문과 동일하게 생각하면 됨

     2. `{{id}}`등의 `{{변수명}}`

        리스트에서 뽑아낸 객체의 필드를 사용

     3. 다음과 같이 사용 가능

        ```
        {{#posts}}
            <tr>
                <td>{{id}}</td>
                <td>{{title}}</td>
                <td>{{author}}</td>
                <td>{{modifiedDate}}</td>
            </tr>
        {{/posts}}
        ```
     
   - 규모가 있는 프로젝트에서는 FK의 조인 등의 복잡한 조건 때문에 entity 클래스만으로 처리하기 어려우므로 조회용 프레임워크를 추가로 사용한다. 대표적으로는 querydsl, jooq, MyBatis 등이 있다. 이 프레임워크들을 이용해서 조회를 하고, SpringDataJpa를 통해 등록/수정/삭제를 진행한다.
   
   - Querydsl을 개인적으로 추천하는 이유
   
     1. 타입 안정성이 보장됨
   
        단순한 문자열로 쿼리를 생성하는 것이 아니라 메소드를 기반으로 쿼리를 생성하므로 오타나 존재하지 않는 컬럼명을 명시할 경우 IDE에서 자동으로 검출됨. 
   
     2. 국내 많은 회사에서 사용중
   
        쿠팡, 배민 등 JPA를 적극적으로 사용하는 회사에서는 Querydsl을 적극적으로 사용중임
   
     3. 레퍼런스가 많음
   
        많은 회사와 개발자들이 사용하므로 국내 자료가 많음
   
   - `@Transactional`에 옵션 `readOnly = true`를 추가하면 트랜잭션 범위는 유지하되, 조회 기능만 남겨두어 조회 속도가 개선됨. 
   
     등록, 수정, 삭제 기능이 전혀 없는 메소드에서 사용하면 좋다.
   
   - 람다식
   
     `.map(PostsListResponseDto::new)`는 `.map(posts -> new PostsListResponseDto(posts))`와 같다.
   
   - `IndexController.java` 의 Model
   
     - 서버 템플릿 엔진에서 사용할 수 있는 객체를 저장할 수 있음
   
     - 여기서는 `postsService.findAllDesc()`로 가져온 결과를 posts로 index.mustache에 전달함
   
       
   
   4.5 게시글 수정, 삭제 화면 만들기
   
   

