# 다양한 연관관계 매핑

## 개요

JPA의 어노테이션은 db와 매핑하기 위해 있는 것. 즉, 다중성(다대일, 일대다..)은 DB 관점에서 고민하면 된다.

헷갈릴 때는, 반대로 생각해 보면 된다. 연관관계에는 대칭성이 있기 때문.

일대다의 반대는 다대일과 같다.

## 단방향, 양방향

### 테이블

외래 키 하나로 양쪽 조인이 가능하다. 방향이라는 개념이 없다.

### 객체
- 참조용 필드가 있는 쪽으로만 참조 가능.

    - ex) member→ team으로 가려면 관련된 reference가 있어야만 갈 수 있다.

- 한쪽만 참조하면 단방향

- 양쪽이 서로 참조하면 양방향

    - 사실 양방향이라는건 없고. 이해를 위해서 만든 것.

    - 객체 입장에서의 방향은 하나

    - member에서 team에 대한 참조 / team에서 member에 대한 참조.
    
    - 단방향을 두개 걸어서 양방향처럼 보이는 것이지 사실은 양방향이 아니다.

## 연관관계의 주인

- 테이블은 외래 키 하나로 두 테이블이 연관관계를 맺는다.

- 객체 양방향 관계는 A→ B, B→ A 처럼 참조가 2군데 걸린 것

- 객체 양방향 관계는 참조가 2군데 있는 것이라서 **두 테이블의 외래키를 관리할 곳을 지정**해야함

    - 내용이 수정될 때 member와 team 중 어떤 것을 고쳐야 할지에 대해서.

- 연관관계의 주인: 외래 키를 관리하는 참조

- 주인의 반대편: 외래 키에 영향을 주지 않음, 단순 조회만 가능

## 다대일

### 다대일 단방향

- 가장 많이 사용하는 연관관계

- 다대일의 반대는 일대다

![image](https://user-images.githubusercontent.com/26156701/109424832-f0abbf00-7a28-11eb-80d6-6b860f9ac326.png)

db입장에서는 team이 일, member가 다 이다.

그럼 '다' 쪽인 member에 외래키가 있어야 한다.

그래야만 member를 한 팀에 여러명 넣을 수 있기 때문이다.

만약 team에 memberid를 넣으면 설계가 잘못된 것.


member에서 team으로만 참조할거야. 가 되면

외래키를 기준으로 외래키가 있는 곳에 연관관계를 걸어주면 된다.

### 다대일 양방향

- 외래 키가 있는 쪽이 연관관계의 주인

- 양쪽을 서로 참조하도록 개발

![image](https://user-images.githubusercontent.com/26156701/109424838-f4d7dc80-7a28-11eb-9242-a345d4a175ed.png)

단방향인 상태에서 반대편에도 하나 추가해주면 된다. 근데 그렇다고 해도 db 테이블에는 영향을 주지는 않는다.

어차피 연관관계의 주인이 있고 그걸로 외래키를 관리하고 있기 때문이다.

반대편은 읽기만 가능하기 때문에, 객체에서 추가만 해주면 된다.


A대B 에서 앞에 나오는 단어가 연관관계의 주인(다대일이면 다가 주인)

양방향으로 가려면 Team에도 List<Member>를 추가해준 뒤, @OneToMany(mappedBy = "")를 추가해주면 된다.

## 일대다

- 일이 연관관계의 주인.

- 일의 방향에서 외래키를 관리하겠다.

### 일대다 단방향

권장하지 않는 모델. 표준스펙에서 지원하기는 하지만 실무에서는 거의 사용하지 않는다.

- 일대다 단방향은 일대다(1:N)에서 일(1)이 연관관계의 주인

- 테이블 일대다 관계는 항상 다(N)쪽에 외래키가 있음

    - 그래서 관계가 틀어진다.

- 객체와 테이블의 차이 때문에 반대편 테이블의 외래 키를 관리하는 특이한 구조

    - 둘의 패러다임이 다르기 때문이다.

- @JoinColumn을 꼭 사용해야 함. 그렇지 않으면 조인 테이블 방식을 사용함(중간에 테이블을 하나 추가함)

    - 안쓰면 중간테이블이 하나 더 생김 (member_id, team_id를 가지고 있는)

    - 이걸 @JoinTable이라고 설정을 할 수 있기는 한데, 장점도 있지만 테이블이 추가돼서 성능저하 + 운영상 어려움으로 인해서 비추천하는 방식. 안넣으면 디폴트가 JoinTable 전략이므로 꼭 넣을 것!

![image](https://user-images.githubusercontent.com/26156701/109424841-f7d2cd00-7a28-11eb-875f-496934f042bc.png)

member와 team이 뒤집어진 상태. team을 중심으로 관리하겠다.

team만 member를 알고 member는 team을 모르는 상태이다.


객체 입장에서는 이런 설계가 나올 수 있지만, db입장에서는 무조건 **다 쪽에 외래키가 들어가야 한다**. 그렇지 않으면 team을 계속 insert해야 해서 중복이 발생하게 된다.


객체지향적으로 손해를 보더라도, member에서 team을 갈 일이 없다고 해도 team_id와 매핑을 걸어서 다대일 양방향으로 매핑을 걸어서 쓰는 것을 추천.

- 일대다 단방향 매핑의 단점

    - 엔티티가 관리하는 외래 키가 다른 테이블에 있음

    - 연관관계 관리를 위해 추가로 UPDATE SQL 실행

- 일대다 단방향 매핑보다는 다대일 양방향 매핑을 사용하자

    - 설계가 복잡해 지더라도 이 방법을 추천. 처음부터 일대다를 쓰지 말자.

### 일대다 양방향

- 이런 매핑은 공식적으로 존재하지 않는다. (JPA 스펙에 없다)

- @JoinColumn(name="", insertable=false, updatable=false)

    - 저 속성을 쓰는 이유는 연관관계 주인을 두개 만들지 않기 위해서 (속성 없이 두개 쓰면 큰일난다.)

    - 저 속성의 의미는 매핑도 되어 있지만 insert나 update를 하지 않게 하는 것.

    - 읽기 전용으로 걸어버리면 사실상 양방향 매핑과 똑같이 되는 것(한쪽은 읽기만 되니까)

- 읽기 전용 필드를 사용해서 양방향 처럼 사용하는 방법

    - 가끔씩 실무에서 필요한 순간이 있다.

- 다대일 양방향을 사용하자

    - 일대다 단방향, 일대다 양방향 둘다 쓰지 말자

![image](https://user-images.githubusercontent.com/26156701/109425052-bf7fbe80-7a29-11eb-8eca-0ca1e895be1b.png)

## 일대일

- 일대일 관계는 그 반대도 일대일이다.

- 주 테이블이나 대상 테이블 중에 외래키 선택가능

    - 주 테이블의 외래 키

    - 대상 테이블의 외래 키

- 외래 키에 데이터베이스 유니크(UNI) 제약조건 추가

    - 일대다, 다대일과 비슷

    - 제약조건을 안넣어도 되지만, 그렇게 되면 관리가 어렵다.

### 일대일: 주 테이블에 외래 키 단방향 정리

- 다대일(@ManyToOne) 단방향 매핑과 유사

![image](https://user-images.githubusercontent.com/26156701/109424844-fc978100-7a28-11eb-880c-4fa358b4c975.png)

member가 locker를 딱 하나만 가질 수 있고, locker 입장에서도 딱 하나의 member만 가질 수 있다.

저렇게 해도 되고, 반대로 locker table에 member_id를 넣어도 된다.

### 일대일: 주 테이블에 외래 키 양방향

- 다대일 양방향 매핑처럼 외래 키가 있는 곳이 연관관계의 주인

- 반대편은 mappedBy 적용

![image](https://user-images.githubusercontent.com/26156701/109424846-fef9db00-7a28-11eb-925d-91e939fc0338.png)

### 일대일: 대상 테이블에 외래 키 단방향

- 단방향 관계는 JPA 지원X

- 양방향 관계는 지원

![image](https://user-images.githubusercontent.com/26156701/109424847-00c39e80-7a29-11eb-8184-db0e9c070eca.png)

### 일대일: 대상 테이블에 외래 키 양방향

- 사실 일대일의 주 테이블에 외래 키 양방향과 매핑 방법은 같음

![image](https://user-images.githubusercontent.com/26156701/109424851-028d6200-7a29-11eb-9547-e1480d7fd0aa.png)

Q. db 설계 상 lockerid를 member가 갖고있는게 좋을까, 아니면 memberid를 locker에 넣는게 좋을까?

A. 둘중 어떤 방법을 쓰더라도 일대일 관계는 성립한다. 그러나 dba입장에서 생각해보면 시간이 흘렀을 때 테이블은 한번 만들어지면 변경하기 힘들다.

시간이 흘러서 비즈니스 룰이 바뀐다면? (한 member가 여러개의 locker를 가질 수 있게 된다면? / 하나의 locker를 여러 member가 쓰게 된다면?) -> 외래 키가 있는 곳을 연관관계의 주인으로 설정하는 것이 편하다.

### 정리

- 주 테이블에 외래키 ← 추천하는 방식

    - 주 객체가 대상 객체의 참조를 가지는 것 처럼 주 테이블에 외래 키를 두고 대상 테이블을 찾음

    - 객체지향 개발자 선호

- JPA 매핑 편리

    - 장점: 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인 가능

    - 단점: 값이 없으면 외래 키에 null 허용

- 대상테이블에외래키

    - 대상 테이블에 외래 키가 존재

    - 전통적인 데이터베이스 개발자 선호

    - 장점: 주 테이블과 대상 테이블을 일대일에서 일대다 관계로 변경할 때 테이블 구조 유지

    - 단점: 프록시 기능의 한계로 지연 로딩으로 설정해도 항상 즉시 로딩됨(프록시는 뒤에서 설명)

## 다대다

- 실무에서 쓰는 것은 추천하지 않는다.

- 관계형 데이터베이스는 정규화된 테이블 2개로 다대다 관계를 표현할 수 없음

- 연결 테이블을 추가해서 일대다, 다대일 관계로 풀어내야함 

![image](https://user-images.githubusercontent.com/26156701/109424974-7cbde680-7a29-11eb-9b3a-cd5a98df35f2.png)

![image](https://user-images.githubusercontent.com/26156701/109424982-80ea0400-7a29-11eb-90d9-09255b564ee9.png)

하나의 회원이 여러 상품 선택 가능 / 하나의 상품도 여러 회원이 담을 수 있음

### DB관점

회원과 상품 테이블만으로는 다대다 관계를 만들 수 없다. 그러므로 연결 테이블이 필요하다.

### 객체관점

반면 객체는 db와 달리 컬렉션을 사용해서 객체 2개로 다대다 관계 가능 (연결테이블 없이도)

ORM입장에서 객체는 되고 테이블은 안되니까 지원해주기 위해 무언가가 필요.

![image](https://user-images.githubusercontent.com/26156701/109424995-8ba49900-7a29-11eb-93a2-551898832d10.png)

![image](https://user-images.githubusercontent.com/26156701/109424997-8e06f300-7a29-11eb-8328-1960274c9702.png)

- @ManyToMany 사용

- @JoinTable로 연결 테이블 지정

- 다대다 매핑: 단방향, 양방향 가능

### 다대다 매핑의 한계

편리해 보이지만 실무에서 사용X

연결 테이블이 단순히 연결만 하고 끝나지 않음

주문시간, 수량 같은 데이터가 들어올 수 있음

내가 생각하지 못한 쿼리가 나올 수 있다. 사용 지양할 것.

![image](https://user-images.githubusercontent.com/26156701/109425000-8f382000-7a29-11eb-8ba0-d9c73608db0a.png)

### 다대다 매핑의 한계 극복

연결 테이블용 엔티티 추가(연결 테이블을 엔티티로 승격)

@ManyToMany -> @OneToMany, @ManyToOne

![image](https://user-images.githubusercontent.com/26156701/109425004-9101e380-7a29-11eb-9a40-6ba8069e75af.png)

![image](https://user-images.githubusercontent.com/26156701/109425007-92331080-7a29-11eb-961c-132aefd34ca2.png)